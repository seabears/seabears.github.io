---
title: OOP
description: >-           #한 문장으로 나옴
  This is OOP
  Write your description here.
date: 2025-01-06 09:28:56 +0900
lastmod : 2025-01-06 09:28:56 +0900  #마지막 수정 시간

author: "seabears"      # 작성자

categories: # 카테고리
    - Uncategorized  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "이 글의 요약"   # 요약
#image: "url_to_image.jpg"   # 대표 이미지 (옵션)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---

### OOP

Object-Oriented Programming

#### 장점

1. 캡슐화 encapsulation : 정보 은닉 information hiding
2. 상속 inheritance
3. 다형성 polymrphism
4. 추상화 abstraction


####  캡슐화
접근 지정자

| 항목 | 간단 설명 | 내용 |
|---|---|---|
| `public` | 공개 멤버 | 클래스 외부에서 자유롭게 접근 가능 |
| `protected` | 보호된 멤버 | 클래스 외부에서 접근 불가능 <br> 파생 클래스(상속받은 클래스) 에서는 가능 |
| `private` | 비공개 멤버 | 클래스 외부, 파생  클래스에서도 접근 불가 <br> 클래스 내부에서만 접근 가능 |



#### 기타

연산자 오버로딩 strcat 대신 "aa" + "bb" = "aabb"  
RAII : 스마트 포인터 : 객체의 라이프 사이클과 리소스 자동 관리, 메모루 누수 해결?
예외 처리
네임스페이스 : 이름 충돌 해결
RTTI 런타임 타입 정보




#### 클래스
객체를 생성하기 위한 설계도
객체는 클래스의 인스턴스, 클래스에 정의된 속성과 동작을 실제로 구현

데이터(멤버 변수)와 동작(멤버 함수)를 하나로 묶는 사용자 정의 자료형




구조체와의 차이 :
기본 접근 수준
| | |
|---|---|
| 구조체(struct) | public |
| 클래스(class) | private |

```cpp
#include <iostream>
using namespace std;

struct StructExample {
    int x; // 기본적으로 public
};

class ClassExample {
    int x; // 기본적으로 private
};

int main() {
    StructExample s;
    s.x = 10; // 접근 가능

    // ClassExample c;
    // c.x = 10; // 오류: private 멤버는 접근 불가능
    return 0;
}
```


#### 멤버 변수 & 멤버 함수
```cpp
#include<iostream>

using namespace::std;

class foo {
	//멤버 변수
	int a;	
	int b;

	//멤버 함수
	void func1() {	
		;
	}	
	void func2() {
		;
	}
};

int main() {

}
```



#### static
static 정적 멤버 변수는 클래스의 모든 객체가 공유
일반 멤버 변수는 객체별 독립
멤버 함수는 공유

#### 클래스 생성 위치
스택이 좋음
메모리 관리 알아서 해주기 때문

#### 객체 생성 방법
1. 스택 : 1순위 권장
2. 힙
    1) malloc
    2) new : 힙에 생성한다면 권장 : 생성자 호출이 가능해서?


#### free 이후에
생성자 주소에 nullptr 넣어서 해제된 객체 사용 막기



#### 초기화
```cpp
int x = 0;  //암묵적 형변환 -> 복사 초기화
int x{0};   //명시적 형변환 -> 타입에 맞지 않을 경우 컴파일 에러 오류 -> 더 안전
```


#### this
현재 객체를 가리키는 포인터
자기 자신의 주소

인스턴스 메서드 안에서만 사용 가능


#### namespace
이름 공간 정의
이름 충돌 방ㅈ

::가 C++에서 우선순위 가장 높음

```cpp
#include<stdio.h>

namespace our {
	void init(){
		printf("our");
	}
}

namespace your {
	void init() {
		printf("your");
	}
}
int main() {

	our::init();

}
```

```cpp
#include<iostream>

using namespace std;
namespace  A {
	void init() {
		cout << "A namespace" << endl;
	}
}
namespace  B {
	void init() {
		cout << "B namespace" << endl;
	}
}
void init() {
	cout << "global namespace" << endl;
}
int main() {
	A::init();
	B::init();
	init();
}
```

<br>

#### using namespace
하나의 함수명만 사용할 경우
그냥 함수명으로 호출 가능
-> 충돌 가능성 있음

<br>

#### cin, cout

```cpp
#include<iostream>

using std::cout;
using std::cin;

int main() {

	int a;
	cin >> a;
	cout << a;

}
```


<br>

#### using, typedef

C++ 가급적 using 사용, typedef 대신
```cpp
#include<iostream>

using namespace std;

typedef int i;
using ii = int;

int main() {
	i a = 1;
	ii b = 2;

	cout << a << endl;
	cout << b << endl;
}
```

<br>

#### auto
복잡한 형태 auto로 단순하게 선언

#### decletype

표현식의 타입을 추론
변수나 함수 반환 값의 타입을 정확하게 알 수 없을 때 유용
```cpp
#include <iostream>

int main() {
    int x = 5;
    decltype(x) y = 2;  // 'x'와 동일한 타입인 'int'로 선언

    std::cout << y << std::endl;  // 출력: 2
    return 0;
}
```

<br>

#### 균일한 초기화 (uniform initialization)
중괄호 `{}`를 사용하여 모든 타입의 변수 초기화 가능
축소 변환(narrowing conversion) 방지 -> 데이터 손실 발생할 수 있는 초기화 허용 x

```cpp
#include <iostream>
#include <string>

class Person {
public:
    std::string name;
    int age;

    Person(std::string n, int a) : name{n}, age{a} {} // 균일한 초기화 사용
};

int main() {
    int a{10};       // 정수 초기화
    double b{3.14};  // 실수 초기화
    char c{'A'};     // 문자 초기화
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << std::endl;


    Person p{"Alice", 25}; // 객체 초기화
    std::cout << "Name: " << p.name << ", Age: " << p.age << std::endl;

    return 0;
}

```


<br>


