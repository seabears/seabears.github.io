---
title: "STM32 GPIO Register ì œì–´"
description: >-           #í•œ ë¬¸ì¥ìœ¼ë¡œ ë‚˜ì˜´
  
date: 2025-02-25 14:38:19 +0900
lastmod : 2025-02-25 14:38:19 +0900  #ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„

author: "seabears"      # ì‘ì„±ì

categories: # ì¹´í…Œê³ ë¦¬
    - Uncategorized  
tags: 
    - Untag1

#image: "url_to_image.jpg"   # ëŒ€í‘œ ì´ë¯¸ì§€ (ì˜µì…˜)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---

## STM32L073RZ pinmap
![STM32L073RZ pinmap](https://github.com/user-attachments/assets/e704b670-8614-43d5-aeb9-b842a6230985)

<br>

## ğŸ“Ÿ STM32 GPIO Register ì œì–´
RM0367 Reference manualì„ í™•ì¸í•˜ë©° ì‘ì„±  
[RM0367 Reference manual](https://www.st.com/resource/en/reference_manual/rm0367-ultralowpower-stm32l0x3-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)  

<br>

GPIO ì œì–´ë¥¼ ìœ„í•´ ë‹¤ìŒ ë‹¨ê³„ê°€ í•„ìš”  
1. RCC GPIO clock enable  
2. GPIO Input/Ouput Mode ì„¤ì •  
3. GPIO Pin ì„¤ì •  

<br>

### ğŸ“Œ 1. RCC_IOPENR
![RCC ìœ„ì¹˜](https://github.com/user-attachments/assets/00f0bdff-116d-4a75-b843-1250529d1f36)

0X4002 1000 - 0X4002 13FF ì— RCC ìœ„ì¹˜  

![RCC_IOPENR offset í™•ì¸](https://github.com/user-attachments/assets/bf8a84c5-8504-4293-8a73-4a2b5a037e29)

RCC_IOPENRì˜ offset : 0x2C  
ì¦‰ 0x4002 1000 + 0x2C ì— RCC_IOPENR ìœ„ì¹˜  

![RCC_IOPENR](https://github.com/user-attachments/assets/fe673c59-e0a5-437b-bd9c-9739a322cd3b)
![RCC_IOPENR_PORTA](https://github.com/user-attachments/assets/804b2a4e-088b-4e3f-a6e3-35a2bc66a928)

RCC_IOPENRì˜ Bit[0:0]ì— 1ë¡œ ì„¤ì •í•˜ì—¬ port A clock enable  

```c
//RCC_IOPENR í™œì„±í™”
//RCC->IOPENR |= 0x1;
*((volatile unsigned int*)0X40021000 + 0x2C) |= 0x1;
```

<br>

### ğŸ“Œ 2. GPIO Input/Ouput Mode ì„¤ì •

![GPIOA](https://github.com/user-attachments/assets/78ef2588-fe92-4ccc-b953-9aa13c199a30)
![GPIOx_MODER](https://github.com/user-attachments/assets/f065d4c4-64df-4ebf-86db-14549f757e55)

GPIOAì˜ ì‹œì‘ ì£¼ì†Œ : 0X5000 0000  
GPIOx_MODERì˜ offset : 0x00  
ì¦‰, GPIOA_MODERì˜ ìœ„ì¹˜ : 0X5000 0000 + 0x00  

PA5(port A, pin 5)ë¥¼ GPIO ì œì–´í•  ê²ƒì´ë¯€ë¡œ `MODE5[1:0]`ë¥¼ `01 : General purpose output mode` ë¡œ ì„¤ì •  

```c
//GPIO : PA5
//GPIOA->MODER &=~(0x3 << (5 * 2));
//GPIOA->MODER |= (val << (5 * 2));
*((volatile unsigned int*)0X50000000 + 0x00) &= ~(0x3 << (5 * 2));   //ë‚˜ë¨¸ì§€ ë¹„íŠ¸ëŠ” ì‚´ë¦¬ê¸°
*((volatile unsigned int*)0X50000000 + 0x00) |=  (0x01 << (5 * 2));  //MODE5[1:0]ë¥¼ 0x01ìœ¼ë¡œ ì„¤ì •
```

<br>

### ğŸ“Œ 3. GPIO pin ì„¤ì •
**ODR ë ˆì§€ìŠ¤í„°ë¡œ ì œì–´ (GPIO port output data register)**  

![GPIO_ODR](https://github.com/user-attachments/assets/e1841546-e140-4bbb-a5ad-5db24786d23c)

GPIOAì˜ ì‹œì‘ ì£¼ì†Œ : 0X5000 0000  
GPIOx_ODRì˜ offset : 0x14  

```c
//GPIOA->ODR &= 0 << 5;
//GPIOA->ODR |= val << 5;

*((volatile unsigned int*)0X50000000 + 0x14) &= (0x0 << 5); //ì´ˆê¸°í™”
*((volatile unsigned int*)0X50000000 + 0x14) |= (0x1 << 5); //HIGH ì„¤ì •
```

<br>

## Interrupt

### NVIC Vector Table
![NVIC Vector Table](https://github.com/user-attachments/assets/1ca9df8f-c4a0-4be1-b1c5-a4d7683d8b9d)

startup_stm32l073xx.sì— interrupt vector table ì •ì˜  

PC13ì„ í†µí•´ Interrupt í•  ê²½ìš°, `EXTI4_15_IRQHandler`ë¥¼ ì •ì˜í•´ì•¼í•¨  
(Pin 4 ~ 15ì˜ Interruptë¥¼ ë‹´ë‹¹)  

```c
/*-----   stm32l0xx_it.c   -----*/
void EXTI4_15_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);  // ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ í˜¸ì¶œ
}

/*-----   stm32l0xx_hal_gpio.c   -----*/
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != RESET)
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
}

__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{	
  UNUSED(GPIO_Pin); //ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë³€ìˆ˜ ì»´íŒŒì¼ëŸ¬ ê²½ê³  ë°©ì§€ìš©
}

/*-----   main.c   -----*/
/*
* ìœ„ì˜ __weakë¡œ ì •ì˜ëœ HAL_GPIO_EXTI_Callbackë¥¼ ì˜¤ë²„ë¼ì´ë“œ
* ì¸í„°ëŸ½íŠ¸ ì„œë¹„ìŠ¤ ë£¨í‹´(ISR)ì— ì‹œê°„ì´ ì˜¤ë˜ê±¸ë¦¬ëŠ” ì‘ì—…ì´ ìˆëŠ” ê²ƒì€ 
* ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ë¥¼ ì ê¸ˆ -> flagë¥¼ í†µí•´ ë©”ì¸ ë£¨í”„ë‚˜ ë‹¤ë¥¸ íƒœìŠ¤í¬ì—ì„œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ìŒ
*/
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{	
  //ì˜¬ë°”ë¥¸ ì˜ˆ
  if(GPIO_Pin == GPIO_PIN_13) {
        flag = 1;  // í”Œë˜ê·¸ë¥¼ ì„¤ì •
    }

  //ì˜¬ë°”ë¥´ì§€ ì•Šì€ ì˜ˆ : ISRì—ì„œ GPIO ì œì–´
	if(GPIO_Pin == GPIO_PIN_13) {
		HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); 
	}
}
```

<br>


---
PB5 -> SW420 ì§„ë™ê°ì§€ì„¼ì„œ ì—°ê²°  

```c
/*-----   stm32l0xx_it.c   -----*/
void EXTI4_15_IRQHandler(void)
{
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
}


/*-----   main.c   -----*/
//PB5 
initval.Pin = GPIO_PIN_5;
initval.Mode = GPIO_MODE_IT_RISING; // Interrupt, Rising Edge ê°ì§€
initval.Pull = GPIO_NOPULL;
initval.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);
HAL_GPIO_Init(GPIOB, &initval);

//EXTI4_15_IRQn ì¸í„°ëŸ½íŠ¸ ì„¤ì •
HAL_NVIC_SetPriority((IRQn_Type)EXTI4_15_IRQn, 0x0D, 0);		//EXTI4_15_IRQn
HAL_NVIC_EnableIRQ((IRQn_Type)EXTI4_15_IRQn);


while (1)
{
  static int cnt = 0;
  static int detect = 1;
  
  if(g_flag){
    if(flag13){
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
      
      detect = !detect;
      
      flag13 = 0;
    }
    if(flag5 && detect){
      if(cnt++ > 10){
        cnt = 0;
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_6);
      }
      flag5 = 0;
    }
    g_flag = 0;
  }
  HAL_Delay(100);
}

// Interrupt Callback
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
	g_flag = 1;
	
	switch(GPIO_Pin){
		case GPIO_PIN_13:
			flag13 = 1;
			break;
		
		case GPIO_PIN_5:
			flag5 = 1;
			break;
		
		default:
			break;
	}
}
```



