---
title: DFS, BFS
description: >-           #한 문장으로 나옴
  This is DFS, BFS
  Write your description here.
date: 2024-12-27 17:39:46 +0900
lastmod : 2024-12-27 17:39:46 +0900  #마지막 수정 시간

author: "seabears"      # 작성자

categories: # 카테고리
    - Uncategorized  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "이 글의 요약"   # 요약
#image: "url_to_image.jpg"   # 대표 이미지 (옵션)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---

#### DFS, BFS

#### DFS
깊이 우선 탐색, Depth-First Search
최대한 깊이 내려간 뒤, 더이상 깊게 갈 곳이 엎을 경우 옆으로 이동

해당 분기를 완벽하게 탐색(한 방향을 갈 수 있을 떄까지 쭉 가기)

구현 : Stack, 재귀함수
<br>


#### DFS
너비 우선 탐색, Breadth-First Search
최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 깊게 이동

구현 : Queue

[text](https://devuna.tistory.com/32)
#### 사용 특징
1) 모든 정점 방문 -> 둘다
2) 경로의 특징

<br>

| 항목  | 내용  | 유리할 때 |
|---|---|---|
|`dfs`| 깊이 우선 탐색  | **1. 모든 경로 다 가볼 때** <br> 2. 목표 노드가 깊을 때<br> 3. 용량<br> 4. dx dy를 목표 노드 방향순으로 설정하면 유리 | 
|`bfs`| 너비 우선 탐색 | **1. 최단 거리** <br> 2. 노드 수 적을 때<br> 3. 얕은 해일 때|

<br>

dfs 백트래킹 필요할 수도도
bfs 최단거리시 typedef struct에 step 변수 넣기


#### 최단 거리 예시

백준 2178번  
https://www.acmicpc.net/problem/2178

```c
#include<stdio.h>
#include<stdbool.h>

#define MAX 100
#define INF 1e9	//10억

#define CAN '1'

typedef struct {
	int x;
	int y;
	int step;
}Pos;

char map[MAX][MAX];
int N, M;

int dx[4] = { 0,0,1,-1 };
int dy[4] = { 1,-1,0,0 };

Pos end;

void input() {
	scanf("%d %d", &N, &M);

	(&end)->x = N - 1;
	(&end)->y = M - 1;


	for (int i = 0;i < N;i++) {
		scanf("%s", &map[i]);
	}

	//printf("end : %d %d\n", end.x, end.y);
}



bool dfs_visited[MAX][MAX] = { 0 };
int dfs_min_step = INF;

void dfs(Pos cur, int step) {
	
	// 현위치 종료조건 체크
	if (cur.x == end.x && cur.y == end.y) {
		if (step < dfs_min_step) {
			dfs_min_step = step;
		}
		return;
	}

	// 현위치 방문 체크
	dfs_visited[cur.x][cur.y] = 1;

	// 현위치 갈 수 있는 곳 체크
	for (int i = 0;i < 4;i++) {
		Pos new = { cur.x + dx[i], cur.y + dy[i] };
		if (map[new.x][new.y] == CAN && !dfs_visited[new.x][new.y] && new.x >=0 && new.x <N && new.y>=0 && new.y<M) {
			//printf("%d %d\n", new.x, new.y);
			dfs(new, step + 1);
		}
	}

	// 백트래킹 : 다시 돌려놓기
	dfs_visited[cur.x][cur.y] = 0;
}



bool bfs_visited[MAX][MAX];
Pos queue[MAX * MAX];
int front = 0, rear = 0;
void enqueue(Pos pos) {
	queue[rear++] = pos;
}
Pos dequeue() {
	return queue[front++];
}
int bfs() {
  // 첫 위치
	enqueue((Pos){ 0,0,1 });
	bfs_visited[0][0] = 1;

	// queue가 비어있지 않을 경우 == 더 이상 갈 곳 없지 않을 경우
	while (front < rear) {
		// 현위치
		Pos cur = dequeue();

		//printf("%d %d %d\n", cur.x, cur.y, cur.step);

		// 현위치 종료 조건 체크
		if (cur.x == end.x && cur.y == end.y) {
			return cur.step;
		}

		// 현위치에서 갈 수 있는 곳 체크
		for (int i = 0;i < 4;i++) {
			Pos new = { cur.x + dx[i], cur.y + dy[i], cur.step + 1 };

			if (new.x >= 0 && new.x < N && new.y>=0 && new.y < M && map[new.x][new.y] == CAN && !bfs_visited[new.x][new.y]) {
				bfs_visited[new.x][new.y] = 1;
				enqueue(new);
			}
		}
	}

	return -1;
}

int main() {
	input();

	Pos cur = { 0,0 };
	dfs(cur, 1);
	printf("dfs : %d\n", dfs_min_step);

	int res = bfs();
	printf("bfs : %d", res);

	return 0;
}
```


<br>

#### 그냥 dfs, bfs

백준 2606번
https://www.acmicpc.net/problem/2606

```c
#include<stdio.h>
#include<stdbool.h>

#define MAX 101

bool map[MAX][MAX];
bool visited[MAX];
int n, m;



int queue[MAX * MAX];
int front = 0, rear = 0;
void enqueue(int cur) {
	queue[rear++] = cur;
}
int dequeue() {
	return queue[front++];
}
void bfs(int start) {
	enqueue(start);
	visited[start] = 1;

	while (front < rear) {
		int cur = dequeue();
		//printf("%d\n", cur);
		for (int i = 1;i <= n;i++) {
			if (map[cur][i] && !visited[i]) {
				visited[i] = 1;
				enqueue(i);
			}
		}
	}

}

void dfs(int cur) {
	
	visited[cur] = 1;

	//printf("%d\n",cur);

	for (int i = 1;i <= n;i++) {
		if (map[cur][i] && !visited[i]) {
			dfs(i);
		}
	}


}

int main() {

	scanf("%d\n%d", &n, &m);

	
	for (int i = 0;i < m;i++) {
		int a, b;
		scanf("%d %d", &a, &b);
		map[a][b] = 1;
		map[b][a] = 1;
	}

	int start = 1;
	
	//dfs(start);
	bfs(start);

	int cnt = 0;
	for (int i = 2;i <= n;i++) {
		if (visited[i]) cnt++;
	}

	printf("%d\n", cnt);

	return 0;
}

```

<br>

#### flood fill (dfs)

백준 2667번
https://www.acmicpc.net/problem/2667
```c
#include<stdio.h>
#include<stdbool.h>
#include<stdlib.h>

#define MAX 26
#define CAN '1'

typedef struct {
	int x;
	int y;
}Pos;

int N;
char map[MAX][MAX];
bool visited[MAX][MAX];
int dx[4] = { 0,0,1,-1 };
int dy[4] = { 1,-1,0,0 };

int cnt = 0;
int home_cnt[MAX * MAX];

void dfs(Pos cur) {
	visited[cur.x][cur.y] = 1;
	home_cnt[cnt]++;

	//printf("%d %d\n", cur.x, cur.y);

	for (int i = 0;i < 4;i++) {
		Pos new = { cur.x + dx[i], cur.y + dy[i] };
		if (new.x >= 0 && new.x < N && new.y >= 0 && new.y < N && map[new.x][new.y] == CAN && !visited[new.x][new.y]) {
			//visited[new.x][new.y] = 1;
			
			dfs(new);
		}
	}
}
int cmp(const void* a, const void* b) {
	return *(int*)a - *(int*)b;
}

int main() {

	scanf("%d", &N);

	for (int i = 0;i < N;i++) {
		scanf("%s", &map[i]);
	}

	for (int i = 0;i < N;i++) {
		for (int j = 0;j < N;j++) {
			if (map[i][j] == CAN && !visited[i][j]) {
				dfs((Pos) { i, j });
				cnt++;
			}
		}
	}

	qsort(home_cnt, cnt, sizeof(int), cmp);

	printf("%d\n", cnt);
	for (int i = 0;i < cnt;i++) {
		printf("%d\n", home_cnt[i]);
	}
	
	return 0;
}
```

<br>


#### 촌수 구하기 (bfs)
백준 2644번
https://www.acmicpc.net/problem/2644

```c
#include<stdio.h>
#include<stdbool.h>

#define MAX 101

typedef struct {
	int n;
	int step;
}Node;

int n;
bool map[MAX][MAX];
bool visited[MAX];

Node queue[MAX*MAX];
int front = 0, rear = 0;
void enqueue(Node n) {
	queue[rear++] = n;
}
Node dequeue() {
	return queue[front++];
}
int bfs(Node a, Node b) {
	enqueue(a);
	visited[a.n] = 1;

	int cnt = 0;
	while (front < rear) {
		Node cur = dequeue();

		//printf("%d\n", cur.n);

		if (cur.n == b.n) return cur.step;

		for (int i = 1;i <= n;i++) {
			if (map[cur.n][i] && !visited[i]) {
				visited[i] = 1;
				Node new = { i, cur.step + 1 };
				
				enqueue(new);
			}
		}
	}

	return -1;
}
int main() {

	scanf("%d", &n);

	int a, b;
	scanf("%d %d", &a, &b);

	int m;
	scanf("%d", &m);
	for (int i = 0;i < m;i++) {
		int x, y;
		scanf("%d %d", &x, &y);
		map[x][y] = 1;
		map[y][x] = 1;
	}

	int res = bfs((Node) { a, 0 }, (Node) { b, 0 });
	printf("%d\n", res);


	return 0;

}
```


<br>


