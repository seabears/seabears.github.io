---
title: Infineon
description: >-           #í•œ ë¬¸ì¥ìœ¼ë¡œ ë‚˜ì˜´
  
date: 2025-02-13 14:42:28 +0900
lastmod : 2025-02-13 14:42:28 +0900  #ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„

author: "seabears"      # ì‘ì„±ì

categories: # ì¹´í…Œê³ ë¦¬
    - Uncategorized  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "ì´ ê¸€ì˜ ìš”ì•½"   # ìš”ì•½
#image: "url_to_image.jpg"   # ëŒ€í‘œ ì´ë¯¸ì§€ (ì˜µì…˜)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---


## âš™ï¸ Infineon MCU Programming

---
### ğŸ“Œ Internal Timer Interrupt
```
State 0 : ë¹¨ê°• LED on (3ì´ˆ)
State 1 : íŒŒë‘ LED on (3ì´ˆ)
State 2 : íŒŒë‘ LED 0.5ì´ˆ ê°„ê²© ì ë©¸
```

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">ì½”ë“œ ë³´ê¸°</summary>
    <div markdown="1" style="margin-top: 10px;">

```c
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"

#include "IfxPort.h"
#include "IfxPort_PinMap.h"

#include "IfxStm.h"
#include "IfxCpu_Irq.h"

enum ledState{
    STATE0 = 0,
    STATE1 = 1,
    STATE2 = 2,
};
int state_val=0;
int blue_toggle=1;
int blink_cnt=0;

#define HIGH 1
#define LOW 0

#define Seconds 3

typedef struct
{
    Ifx_STM             *stmSfr;            /**< \brief Pointer to Stm register base */
    IfxStm_CompareConfig stmConfig;         /**< \brief Stm Configuration structure */
    volatile uint8       LedBlink;          /**< \brief LED state variable */
    volatile uint32      counter;           /**< \brief interrupt counter */
} App_Stm;

App_Stm g_Stm; /**< \brief Stm global data */

IfxCpu_syncEvent g_cpuSyncEvent = 0;

void IfxStmDemo_init(void);
void IfxStmDemo2_init(void);

int core0_main(void) {
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);

    IfxStmDemo_init();

    /*P10_2    Digital Output*/
    IfxPort_setPinModeOutput(IfxPort_P10_2.port, IfxPort_P10_2.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(IfxPort_P10_2.port, IfxPort_P10_2.pinIndex);

    /*P10_1    Digital Output*/
    IfxPort_setPinModeOutput(IfxPort_P10_1.port, IfxPort_P10_1.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(IfxPort_P10_1.port, IfxPort_P10_1.pinIndex);

    while(1)
    {

    }
    return (1);
}

IFX_INTERRUPT(STM_Int0Handler, 0, 100);

void STM_Int0Handler(void)
{
    IfxStm_clearCompareFlag(g_Stm.stmSfr, g_Stm.stmConfig.comparator);

    switch(state_val){
        case STATE0:
            IfxStm_increaseCompare(g_Stm.stmSfr, g_Stm.stmConfig.comparator, 100000000u * Seconds);

            state_val += 1;
            IfxPort_setPinHigh(IfxPort_P10_1.port, IfxPort_P10_1.pinIndex); //red  on
            IfxPort_setPinLow(IfxPort_P10_2.port, IfxPort_P10_2.pinIndex); //blue off
            break;

        case STATE1:
            IfxStm_increaseCompare(g_Stm.stmSfr, g_Stm.stmConfig.comparator, 100000000u * Seconds);

            state_val += 1;
            IfxPort_setPinLow(IfxPort_P10_1.port, IfxPort_P10_1.pinIndex); //red  of
            IfxPort_setPinHigh(IfxPort_P10_2.port, IfxPort_P10_2.pinIndex); //blue on

            break;

        case STATE2:
            IfxStm_increaseCompare(g_Stm.stmSfr, g_Stm.stmConfig.comparator, 50000000u);    //cmp reg ì›í•˜ëŠ” ì‹œê°„ìœ¼ë¡œ ë‹¤ì‹œ ì‹¤í–‰

            if(blink_cnt++ < Seconds * 2){
                if(blue_toggle){
                    IfxPort_setPinLow(IfxPort_P10_2.port, IfxPort_P10_2.pinIndex); //blue on
                    blue_toggle= 0;
                }
                else {
                    IfxPort_setPinHigh(IfxPort_P10_2.port, IfxPort_P10_2.pinIndex); //blue on
                    blue_toggle= 1;
                }
            }
            else  if(blink_cnt >= Seconds * 2) {
                state_val = 0;  //State ì´ë™
                blink_cnt=0;  //ê¹œë¹¡ì´ cnt ì´ˆê¸°í™”
            }
            break;
        default:
            break;
    }

    IfxCpu_enableInterrupts();
}

void IfxStmDemo_init(void)
{
    /* disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    IfxStm_enableOcdsSuspend(&MODULE_STM0);

    g_Stm.stmSfr = &MODULE_STM0;
    IfxStm_initCompareConfig(&g_Stm.stmConfig);

    g_Stm.stmConfig.triggerPriority = 100u;
    g_Stm.stmConfig.typeOfService   = IfxSrc_Tos_cpu0;
    g_Stm.stmConfig.ticks           = 100000000 * Seconds;

    IfxStm_initCompare(g_Stm.stmSfr, &g_Stm.stmConfig);

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);
}
```

</div>
</details>
<br>

---

### 




