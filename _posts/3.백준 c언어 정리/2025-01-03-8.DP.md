---
title: DP
description: >-           #한 문장으로 나옴
  This is DP
  Write your description here.
date: 2025-01-03 16:00:21 +0900
lastmod : 2025-01-03 16:00:21 +0900  #마지막 수정 시간

author: "seabears"      # 작성자

categories: # 카테고리
    - Uncategorized  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "이 글의 요약"   # 요약
#image: "url_to_image.jpg"   # 대표 이미지 (옵션)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---

### DP

#### DP, DPS, BFS 시간 비교
백준 1463번
https://www.acmicpc.net/problem/1463

Dp : 4ms, 메모리 : 4900 KB
```c
#include <stdio.h>
#include <limits.h> // INT_MAX 사용을 위해 포함

#define MAX 1000001

int main() {
    int N;
    scanf("%d", &N);

    int dp[MAX]; // 1부터 N까지 각 최소 연산 횟수 저장할 배열

    dp[1] = 0; // 1은 이미 1이므로 연산이 필요 없음

    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + 1; // 1을 뺀 경우

        if (i % 2 == 0) {
            dp[i] = (dp[i] < dp[i / 2] + 1) ? dp[i] : dp[i / 2] + 1; // 2로 나눈 경우
        }

        if (i % 3 == 0) {
            dp[i] = (dp[i] < dp[i / 3] + 1) ? dp[i] : dp[i / 3] + 1; // 3으로 나눈 경우
        }
    }

    printf("%d\n", dp[N]); // N을 1로 만드는 최소 연산 횟수 출력

    return 0;
}

```

my_Dfs : 64ms, 메모리 : 51772 KB
```c
#include <stdio.h>
#include <limits.h>

#define MAX_N 1000000

int min_step = INT_MAX; // 최소 연산 수 저장
int visited[MAX_N + 1] = { 0 }; // 각 값의 최소 연산 횟수 기록

void dfs(int n, int step) {

    //printf("cur : %d | step : %d\n", n, step);
    // 숫자가 1이면 최소 연산 수 갱신
    if (n == 1) {
        if (step < min_step) {
            min_step = step;
        }
        return;
    }

    //시간 줄이기 위한
    // 이미 방문했거나, 현재 연산이 최소 연산 이상인 경우 탐색 중단
    if (visited[n] && step >= visited[n]) {
        return;
    }
    visited[n] = step; // 현재 상태 방문 기록


    // 가능한 연산 수행
    if (n % 3 == 0) {
        dfs(n / 3, step + 1);
    }
    if (n % 2 == 0) {
        dfs(n / 2, step + 1);
    }
    dfs(n - 1, step + 1); // 항상 가능
}

int main() {
    int N;
    scanf("%d", &N);

    dfs(N, 0);

    printf("%d\n", min_step);

    return 0;
}

```


Dfs : 8ms, 메모리 : 5016 KB
```c
#include <stdio.h>
#include <limits.h>

#define MAX_N 1000000

int min_step = INT_MAX; // 최소 연산 수 저장
int visited[MAX_N + 1] = {0}; // 방문 여부 기록

void dfs(int n, int step) {

    //printf("cur : %d | step : %d\n", n, step);
    // 숫자가 1이면 최소 연산 수 갱신
    if (n == 1) {
        if (step < min_step) {
            min_step = step;
        }
        return;
    }

    // 이미 방문했거나, 현재 연산이 최소 연산 이상인 경우 탐색 중단
    if (visited[n] && step >= visited[n]) {
        return;
    }

    visited[n] = step; // 현재 상태 방문 기록

    // 가능한 연산 수행
    if (n % 3 == 0) {
        dfs(n / 3, step + 1);
    }
    if (n % 2 == 0) {
        dfs(n / 2, step + 1);
    }
    dfs(n - 1, step + 1); // 항상 가능
}

int main() {
    int N;
    scanf("%d", &N);

    dfs(N, 0);

    printf("%d\n", min_step);

    return 0;
}


```


BFS : 0ms, 메모리 : 9784 KB
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_N 1000000

typedef struct {
    int n;      // 현재 숫자
    int step;   // 현재까지 수행한 연산 수
} Node;

int bfs(int start) {
    bool visited[MAX_N + 1] = {false}; // 방문 여부 기록
    Node queue[MAX_N];
    int front = 0, rear = 0;

    // 초기 상태 삽입
    queue[rear++] = (Node) {start, 0};
    visited[start] = true;

    while (front < rear) {
        Node cur = queue[front++];
        
        // 숫자가 1이 되면 최소 단계를 반환
        if (cur.n == 1) {
            return cur.step;
        }

        // 가능한 다음 상태 삽입
        if (cur.n % 3 == 0 && !visited[cur.n / 3]) {
            queue[rear++] = (Node) {cur.n / 3, cur.step + 1};
            visited[cur.n / 3] = true;
        }
        if (cur.n % 2 == 0 && !visited[cur.n / 2]) {
            queue[rear++] = (Node) {cur.n / 2, cur.step + 1};
            visited[cur.n / 2] = true;
        }
        if (cur.n - 1 > 0 && !visited[cur.n - 1]) {
            queue[rear++] = (Node) {cur.n - 1, cur.step + 1};
            visited[cur.n - 1] = true;
        }
    }

    return -1; // 도달할 수 없는 경우
}

int main() {
    int N;
    scanf("%d", &N);

    int result = bfs(N);
    printf("%d\n", result);

    return 0;
}

```

<br>

#### 사칙연산 DP
백준 9095번
https://www.acmicpc.net/problem/9095
```c
#include<stdio.h>

#define MAX 11

int dp[MAX];

void sol() {
	dp[1] = 1;	// 1
	dp[2] = 2;	// 1+1, 2
	dp[3] = 4;	// 1+1+1, 1+2, 2+1, 3

	for (int i = 4;i < MAX;i++) {
		dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
	}
}
int main() {
	int T;
	scanf("%d", &T);

	sol();

	for (int i = 0;i < T;i++) {
		int n;
		scanf("%d", &n);

		int res = dp[n];
		printf("%d\n", res);
	}

	return 0;
}
```


초기값 : dp[1], dp[2], dp[3]
점화식 : dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

<br>

