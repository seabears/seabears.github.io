---
title: 이진 탐색(Binary Search)
description: >-           #한 문장으로 나옴
  백준 문제풀이
date: 2024-12-24 14:05:57 +0900
#lastmod : 2024-12-24 14:05:57 +0900  #마지막 수정 시간

author: "seabears"      # 작성자

categories: # 카테고리
    - 백준 c언어 정리  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "이 글의 요약"   # 요약
#image: "url_to_image.jpg"   # 대표 이미지 (옵션)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---

## 이진 탐색  

### 14425번  

[백준 14425번](https://www.acmicpc.net/problem/14425)  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">수정 전 코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">

```c
#include<stdio.h>
#include<string.h>

#define MAX 10000
#define LEN_MAX 501

int strcheck(char* str, int s[LEN_MAX], int n) {

	int a = 0;
	for (int i = 0;str[i] != '\0';i++) {
		a += str[i] * str[i] * (i + 1) * (i + 1);
	}
	for (int i = 0;i < n;i++) {
		if (s[i] == a) return 0;
	}
	return 1;

}
int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	
	int s[MAX];
	for (int i = 0;i < n;i++) {
		char temp[LEN_MAX];
		scanf("%s", temp);

		s[i] = 0;
		for (int j = 0;temp[j] != '\0';j++) {
			s[i] += temp[j] * temp[j] * (j + 1) * (j + 1);
		}
	}
	
	int check = 0;
	for (int i = 0;i < m;i++) {
		char temp[LEN_MAX];
		scanf("%s", temp);
		if (strcheck(temp, s, n) == 0)check++;
	}
	printf("%d", check);
	
	return 0;
}
```

</div>
</details>

<br>

이진 탐색으로 변환  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">수정 후 코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int n, m, i, num = 0, cmp, start, mid, end;
char list[10000][501], temp[501];

int main(void) {
	scanf("%d %d ", &n, &m);
	for (i = 0; i < n; i++) {
		gets(list[i]);
	}

	qsort(list, n, sizeof(char) * 501, strcmp); //사전순 정렬

	for (i = 0; i < m; i++) {
		gets(temp);

		start = 0;
		end = n - 1;

		while (start <= end) {
			mid = (start + end) / 2;
			cmp = strcmp(temp, list[mid]);  //중간 확인인


			if (!cmp) {
				num++;
				break;
			}
			else if (cmp < 0) end = mid - 1;  //사전순 앞
			else start = mid + 1;             //사전순 뒤
		}
	}

	printf("%d", num);
}
```

</div>
</details>


-> 
qsort(list, n, sizeof(char) * 501, strcmp);  
qsort에 strcmp를 이용하면 바로 사전순 정렬 가능  


<br>


### 이진 탐색을 잘 설명하는 문제  
[백준 1920번](https://www.acmicpc.net/problem/1920)

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>
#include<stdlib.h>

#define MAX 100001

int cmp(const void* a, const void* b) {
	int numa = *(int*)a;
	int numb = *(int*)b;
	//return numa-numb;은 overflow 발생(자료형 long long으로 변환도 가능) 
	if (numa > numb) return 1;
	else if (numa == numb)return 0;
	else if (numa < numb) return -1;
}
int find(int arr[MAX], int endIndex, int num) {
	int start = 0;
	int end = endIndex - 1;
	int middle = 0;
	while (start <= end) {
		middle = (start + end) / 2;

		//printf("start: %d, end: %d, mid : %d\n", arr[start], arr[end], arr[middle]);

		if (arr[middle] == num) break;
		else if (arr[middle] > num) end = middle - 1;
		else if (arr[middle] < num) start = middle + 1;
	}

	if (arr[middle] == num) return 1;
	else return 0;
}
int main() {
	int N;
	scanf("%d", &N);
	int numArr[MAX];
	for (int i = 0;i < N;i++) {
		scanf("%lld", &numArr[i]);
	}
	qsort(numArr, N, sizeof(int), cmp);

	int M;
	scanf("%d", &M);
	int num;
	for (int i = 0;i < M;i++) {
		scanf("%d", &num);

		int res = find(numArr, N, num);
		printf("%d\n", res);

	}
	return 0;
}
```

</div>
</details>

<br>

