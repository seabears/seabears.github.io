---
title: 이진 탐색(Binary Search)
description: >-           #한 문장으로 나옴
  백준 문제풀이
date: 2024-12-24 14:05:57 +0900
#lastmod : 2024-12-24 14:05:57 +0900  #마지막 수정 시간

author: "seabears"      # 작성자

categories: # 카테고리
    - 백준 c언어 정리  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "이 글의 요약"   # 요약
#image: "url_to_image.jpg"   # 대표 이미지 (옵션)
#permalink: /category1/first-post/
pin: false              # true | false
published: true        # true | false
---

## 이진 탐색  

### 14425번  

[백준 14425번](https://www.acmicpc.net/problem/14425)  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">수정 전 코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">

```c
#include<stdio.h>
#include<string.h>

#define MAX 10000
#define LEN_MAX 501

int strcheck(char* str, int s[LEN_MAX], int n) {

	int a = 0;
	for (int i = 0;str[i] != '\0';i++) {
		a += str[i] * str[i] * (i + 1) * (i + 1);
	}
	for (int i = 0;i < n;i++) {
		if (s[i] == a) return 0;
	}
	return 1;

}
int main() {
	int n, m;
	scanf("%d %d", &n, &m);
	
	int s[MAX];
	for (int i = 0;i < n;i++) {
		char temp[LEN_MAX];
		scanf("%s", temp);

		s[i] = 0;
		for (int j = 0;temp[j] != '\0';j++) {
			s[i] += temp[j] * temp[j] * (j + 1) * (j + 1);
		}
	}
	
	int check = 0;
	for (int i = 0;i < m;i++) {
		char temp[LEN_MAX];
		scanf("%s", temp);
		if (strcheck(temp, s, n) == 0)check++;
	}
	printf("%d", check);
	
	return 0;
}
```

</div>
</details>

<br>

이진 탐색으로 변환  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">수정 후 코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int n, m, i, num = 0, cmp, start, mid, end;
char list[10000][501], temp[501];

int main(void) {
	scanf("%d %d ", &n, &m);
	for (i = 0; i < n; i++) {
		gets(list[i]);
	}

	qsort(list, n, sizeof(char) * 501, strcmp); //사전순 정렬

	for (i = 0; i < m; i++) {
		gets(temp);

		start = 0;
		end = n - 1;

		while (start <= end) {
			mid = (start + end) / 2;
			cmp = strcmp(temp, list[mid]);  //중간 확인인


			if (!cmp) {
				num++;
				break;
			}
			else if (cmp < 0) end = mid - 1;  //사전순 앞
			else start = mid + 1;             //사전순 뒤
		}
	}

	printf("%d", num);
}
```

</div>
</details>


-> 
qsort(list, n, sizeof(char) * 501, strcmp);  
qsort에 strcmp를 이용하면 바로 사전순 정렬 가능  


<br>


### 이진 탐색을 잘 설명하는 문제  
[백준 1920번](https://www.acmicpc.net/problem/1920)

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>
#include<stdlib.h>

#define MAX 100001

int cmp(const void* a, const void* b) {
	int numa = *(int*)a;
	int numb = *(int*)b;
	//return numa-numb;은 overflow 발생(자료형 long long으로 변환도 가능) 
	if (numa > numb) return 1;
	else if (numa == numb)return 0;
	else if (numa < numb) return -1;
}
int find(int arr[MAX], int endIndex, int num) {
	int start = 0;
	int end = endIndex - 1;
	int middle = 0;
	while (start <= end) {
		middle = (start + end) / 2;

		//printf("start: %d, end: %d, mid : %d\n", arr[start], arr[end], arr[middle]);

		if (arr[middle] == num) break;
		else if (arr[middle] > num) end = middle - 1;
		else if (arr[middle] < num) start = middle + 1;
	}

	if (arr[middle] == num) return 1;
	else return 0;
}
int main() {
	int N;
	scanf("%d", &N);
	int numArr[MAX];
	for (int i = 0;i < N;i++) {
		scanf("%lld", &numArr[i]);
	}
	qsort(numArr, N, sizeof(int), cmp);

	int M;
	scanf("%d", &M);
	int num;
	for (int i = 0;i < M;i++) {
		scanf("%d", &num);

		int res = find(numArr, N, num);
		printf("%d\n", res);

	}
	return 0;
}
```

</div>
</details>

<br>


### 숫자 카드 나열해주고 몇개인지 찾기  
[백준 10816번](https://www.acmicpc.net/problem/10816)

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">방법 1 코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define MAX 500001

int cmp(const void* a, const void* b) {
	return *(int*)a - *(int*)b;
}
int getHowManyHave(int card[MAX][2], int n, int num) {
	int start = 0;
	int end = n - 1;
	int middle = 0;

	while (start <= end) {
		middle = (start + end) / 2;

		if (card[middle][0] == num) break;
		else if (card[middle][0] > num) end = middle - 1;
		else if (card[middle][0] < num) start = middle + 1;
	}

	if (card[middle][0] == num) return card[middle][1];
	else return 0;
}
int main() {
	int N;
	scanf("%d", &N);
	int card[MAX];
	memset(card, 0, sizeof(card));
	for (int i = 0;i < N;i++) {
		scanf("%d", &card[i]);
	}

	qsort(card, N, sizeof(int), cmp);

	int organized_card[MAX][2];
	int index = 0;
	int cnt = 1;
	for (int i = 1;i < N;i++) {
		if (card[i - 1] == card[i]) cnt++;
		else {
			organized_card[index][0] = card[i - 1];
			organized_card[index++][1] = cnt;
			cnt = 1;
		}
	}
	organized_card[index][0] = card[N - 1];
	organized_card[index++][1] = cnt;
	
	int M;
	scanf("%d", &M);
	int num;
	for (int i = 0;i < M;i++) {
		scanf("%d", &num);

		int res = getHowManyHave(organized_card, index, num);
		printf("%d ", res);
	}

	return 0;
}
```

</div>
</details>

<br>

**`lower_bound`, `upper_bound` 찾기로 수정**  
각 bound 찾는 방법 알아두기  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">방법 2 코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>
#include<string.h>
#include<stdlib.h>

#define MAX 500001

int cmp(const void* a, const void* b) {
	return *(int*)a - *(int*)b;
}
//lower_bound: key 시작값 찾기 //오른쪽 끝 수는 key 이전 값
int lower_bound(int card[MAX], int N, int key) {
	int start = 0, end = N - 1;
	while (start <= end) {
		int mid = (start + end) / 2;

		printf("lower_mid : %d | %d %d\n", mid, start, end);

		if (card[mid] >= key) end = mid - 1;
		else start = mid + 1;
	}
	return start;
}
// upper_bound: 처음으로 key 초과 나오는 위치 찾기 //오른쪽 끝 수는 key 끝값
int upper_bound(int* arr, int N, int key) {
	int start = 0, end = N - 1;
	while (start <= end) {
		int mid = (start + end) / 2;

		printf("upperr_mid : %d | %d %d\n", mid, start, end);

		if (arr[mid] > key) end = mid - 1;
		else start = mid + 1;
	}
	return start;
}
int main() {
	int N;
	scanf("%d", &N);
	int card[MAX];
	memset(card, 0, sizeof(card));
	for (int i = 0;i < N;i++) {
		scanf("%d", &card[i]);
	}

	qsort(card, N, sizeof(int), cmp);

	printf("\n");
	for (int i = 0;i < N;i++) printf("%d ", card[i]);
	printf("\n");
	
	int M;
	scanf("%d", &M);
	int num;
	for (int i = 0;i < M;i++) {
		scanf("%d", &num);

		int res = upper_bound(card, N, num) - lower_bound(card, N, num);
		printf("%d ", res);
	}
	return 0;
}
```

</div>
</details>

<br>

### 차집합 : 그냥 이진 탐색 중 하나  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>
#include<stdlib.h>

#define MAX 500001

int cmp(const void* a, const void* b) {
	return *(int*)a - *(int*)b;
}
int BinarySearch(int arr[MAX], int size, int key) {
	int start = 0, end = size - 1;
	int mid = 0;
	while (start <= end) {
		mid = (start + end) / 2;

		if (arr[mid] == key) break;
		else if (arr[mid] > key) end = mid - 1;
		else if (arr[mid] < key) start = mid + 1;
	}
	//printf("mid : %d\n", arr[mid]);
	if (arr[mid] == key) return 1;
	else return -1;
}
int main() {
	int nA, nB;
	scanf("%d %d", &nA, &nB);

	int A[MAX], B[MAX];
	for (int i = 0;i < nA;i++) {
		scanf("%d", &A[i]);
	}
	for (int i = 0;i < nB;i++) {
		scanf("%d", &B[i]);
	}
	qsort(A, nA, sizeof(int), cmp);
	qsort(B, nB, sizeof(int), cmp);

	int cnt = 0;
	int arr[MAX];
	for (int i = 0;i < nA;i++) {
		int res = BinarySearch(B, nB, A[i]);
		if (res == -1) {
			arr[cnt] = A[i];
			cnt++;
		}
		else continue;
	}

	printf("%d\n", cnt);
	for (int i = 0;i < cnt;i++) {
		printf("%d ", arr[i]);
	}

	return 0;
}
```

</div>
</details>

<br>

