---
title: 백트래킹
description: >-           #한 문장으로 나옴
  
date: 2025-02-11 11:44:48 +0900
lastmod : 2025-02-11 11:44:48 +0900  #마지막 수정 시간

author: "seabears"      # 작성자

categories: # 카테고리
    - Uncategorized  
tags: 
    - Untag1

sitemap :
  changefreq : daily
  priority : 1.0

#excerpt: "이 글의 요약"   # 요약
#image: "url_to_image.jpg"   # 대표 이미지 (옵션)
#permalink: /category1/first-post/
pin: false              # true | false
published: false        # true | false
---


## 🔍 백트래킹
백트래킹은 "가능한 모든 해"를 탐색하는 과정에서, 불필요한 경로를 미리 차단하고, 유효하지 않은 경로는 되돌려서 다른 경로를 탐색하는 알고리즘  

### 📌 1. 1부터 N까지에서 골라  길이가 M인 모든 수를 출력
[백준 15649](https://www.acmicpc.net/problem/15649)  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>
#include<string.h>
#include<stdbool.h>

#define MAX (8+1)

int N, M;
int seq[9];
bool visited[9];

void backtrack(int index) {
	if (index == M) {	//M개 수 다 선택하면 출력
		for (int i = 0;i < M;i++) {
			printf("%d ", seq[i]);
		}
		printf("\n");
		return;
	}

	for (int i = 1;i <= N;i++) {	//1부터 N까지
		if (!visited[i]) {
			visited[i] = 1;	//방문 표시
			seq[index] = i;	//배열에 추가
			backtrack(index + 1);
			visited[i] = 0;	//방문 되돌리기
		}	
	}
}

int main() {

	scanf("%d %d", &N, &M);

	backtrack(0);	//index는 0부터

	return 0;
}

/*
1~N 자연수 중에서 중복 없이 길이가 M인 수열을 모두 구하라

*/
```

</div>
</details>
<br>

--- 
### 📌 2. 스도쿠
[백준 2580번](https://www.acmicpc.net/problem/2580)  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">

```c
#include<stdio.h>

#define MAX (9+1)

int board[MAX][MAX];

int issafe(int row, int col, int val) {

    for (int i = 0; i < 9; i++) {   //가로 세로 유효여부 확인
        if (board[row][i] == val || board[i][col] == val) {
            return 0;
        }
    }

    int start_row = row - row % 3;
    int start_col = col - col % 3;
    /*
    if (row % 3 == 0) start_row = row;
    else if (row % 3 == 1) start_row = row - 1;
    else if (row % 3 == 2) start_row = row - 2;

    if (col % 3 == 0) start_row = col;
    else if (col % 3 == 1) start_col = col - 1;
    else if (col % 3 == 2) start_col = col - 2;
    */
    for (int i = start_row; i < start_row + 3; i++) {   //3x3 유효여부 확인
        for (int j = start_col; j < start_col + 3; j++) {
            if (board[i][j] == val) {
                return 0;
            }
        }
    }

    return 1;
}
void print() {
    for (int j = 0; j < 9; j++) {
        for (int k = 0; k < 9; k++) {
            printf("%d ", board[j][k]);
        }
        printf("\n");
    }
}
int beReturn() {    //모든 칸 다 채웠는지 확인
    int ret = 1;
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            if (board[i][j] == 0) ret = 0;
        }
    }
    return ret;
}
int ret_flag = 0;
void solve() {

    if (ret_flag) return;

    if (beReturn()) {   //원하는 목표 도달시 return flag = 1;
        ret_flag = 1;
        return;
    }

    //빈곳 찾기
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {   //col
            if (board[i][j] == 0) {
                for (int k = 1; k <= 9; k++) {

                    if (issafe(i, j, k)) {
                        board[i][j] = k;
                        solve();
                        if(!ret_flag) board[i][j] = 0;   //원하는 목표 도달 못하면 다시 되돌리기
                    }
                    //
                }
                return;
            }
        }
    }
}

int main() {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            scanf("%d", &board[i][j]);
        }
    }

    solve();

    if (ret_flag) {
        print();
    }


    return 0;
}
```

</div>
</details>
<br>

---
### 📌 3. 수열의 합 특정 값인 부분 수열의 개수
[백준 1182번](https://www.acmicpc.net/problem/1182)  

<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>

#define MAX (20+1)

int N, S;
int num[MAX];

int cnt = 0;
void solve(int index, int sum, int num_cnt) {
   /*
   index   : num배열에서 선택/미선택할 원소 인덱스
   sum      : 현재 분기까지의 합
   num_cnt : 선택한 원소의 개수(문제 조건 : 양수여야 함)
   */

   if (index == N) {
      if (sum == S && num_cnt > 0) cnt++;
      return;
   }

   //1. 포함
   solve(index + 1, sum + num[index], num_cnt + 1);

   //2. 미포함
   solve(index + 1, sum, num_cnt);

}
int main() {

   scanf("%d %d", &N, &S);
   for (int i = 0;i < N;i++) {
      scanf("%d", &num[i]);
   }
   
   solve(0, 0, 0);

   printf("%d\n", cnt);

   return 0;
}

/*
요구사항 : 부분수열의 합이 S인 경우의 수

-> 부분 수열을 선택

1. 현재 원소를 포함하는 경우
2.            포함 안하는 경우

*/
```

</div>
</details>
<br>

---
### 📌 4. N과 M(2)
[백준 16560번](https://www.acmicpc.net/problem/15650)  
<details style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">
    <summary style="font-weight: bold; cursor: pointer;">코드 보기</summary>
    <div markdown="1" style="margin-top: 10px;">


```c
#include<stdio.h>

#define MAX (8+1)

int N, M;

int ans[MAX];
int issafe(int num) {
	
	for (int i = 0;i < M;i++) {
		if (ans[i] == num) return 0;
	}
	return 1;
}
void solve(int selectNum, int selectCnt) {
	if (selectCnt == M) {
		for (int i = 0;i < M;i++) {
			printf("%d ", ans[i]);
		}
		printf("\n");
		return;
	}
	
	for (int i = selectNum;i <= N;i++) {
		if (issafe(i)) {
			ans[selectCnt] = i;
			solve(i, selectCnt + 1);
			ans[selectCnt] = 0;	//다른 곳에서 탐색할 때 유효하지 않은 index에서 걸리지 않도록
		}
	}
}

int main() {

	scanf("%d %d", &N, &M);

	solve(1, 0);

	return 0;
}
/*
1~N에서 중복 없이 M개를 골라라

1. 일단 차례대로 골라서 저장, 출력
2. 하나 빠꾸 저장 수정, 출력
...

*/
```

</div>
</details>
<br>

---

### 📌 5.